use anyhow::{Context, Result};
use std::fmt::Write;
use std::fs::{self, DirEntry, File};
use std::io::prelude::*;
use std::io::BufReader;
use std::path::Path;

const ICALLS_PATH: &str = "../extern/libil2cpp/il2cpp/libil2cpp/icalls/";
const OUTPUT_PATH: &str = "../src/Codegen/ICalls.cpp";

#[derive(Debug)]
struct Class {
    name: String,
    namespace: String,
    funcs: Vec<String>,
    include_path: String,
}

// Straight out of the read_dir example
fn visit_dirs(dir: &Path, cb: &dyn Fn(&DirEntry) -> Result<Option<Class>>) -> Result<Vec<Class>> {
    let mut classes = Vec::new();
    if dir.is_dir() {
        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                classes.append(&mut visit_dirs(&path, cb)?);
            } else {
                if path.extension().context("no extension")? != "h" {
                    continue;
                }
                let class = cb(&entry)?;
                if let Some(class) = class {
                    classes.push(class);
                }
            }
        }
    }
    Ok(classes)
}

fn parse_header(dir_entry: &DirEntry) -> Result<Option<Class>> {
    let path = dir_entry.path();
    let path_str = path.to_str().context("path to string")?;
    let include_path = &path_str[path_str.find("icalls/").context("path find")?+7..];
    let include_path = include_path.to_owned();

    let file = File::open(path)?;
    let reader = BufReader::new(file);

    let mut namespace = String::new();
    let mut name = None;
    let mut funcs = Vec::new();

    for line in reader.lines() {
        let line = line?;
        let line = line.trim_start();
        if line.starts_with("namespace") {
            namespace.push_str("::");
            namespace.push_str(line.trim_start_matches("namespace "));
        } else if line.starts_with("class") {
            let new_name = line.trim_start_matches("class LIBIL2CPP_CODEGEN_API ");
            name = Some(new_name.to_owned());
        } else if line.starts_with("static") {
            let func = line.trim_start_matches("static ").trim_end_matches(';');
            if !func.ends_with(')') {
                continue;
            }
            funcs.push(func.to_owned());
        } else if line.starts_with("#if") { // check for IL2CPP_TINY, seems to always be on the bottom
            break;
        }
    }

    let name = match name {
        Some(name) => name,
        None => return Ok(None),
    };

    Ok(Some(Class {
        name,
        namespace,
        funcs,
        include_path,
    }))
}

fn write_class(str: &mut String, class: &Class) -> Result<()> {
    println!("Writing class {}::{}", class.namespace, class.name);
    writeln!(str, "#include \"icalls/{}\"", class.include_path)?;
    let namespace_trimmed = class.namespace.trim_start_matches("::");
    writeln!(str, "namespace {} {{", namespace_trimmed)?;

    for func in &class.funcs {
        let skip = func.starts_with("const") as usize + 1;
        let (mut ret, mut rest) = {
            let vec: Vec<&str> = func.split(' ').collect();
            (vec[0..skip].join(" "), vec[skip..].join(" "))
        };
        if rest.starts_with('*') {
            rest.remove(0);
            ret.push('*');
        }
        write!(str, "{} {}::{}", ret, class.name, rest)?;
        str.write_str(" { SAFE_ABORT(); }\n")?;
    }

    writeln!(str, "}} // end namespace {}", namespace_trimmed)?;
    Ok(())
}

fn main() -> Result<()> {
    let icalls_path = Path::new(ICALLS_PATH);
    let classes = visit_dirs(icalls_path, &parse_header)?;

    let mut str = String::new();
    str.write_str("// Generated by il2cpp_icalls_codegen, do not edit by hand\n")?;
    str.write_str("#include \"codegen/il2cpp-codegen.h\"\n")?;
    str.write_str("#include \"beatsaber-hook/shared/utils/utils.h\"\n")?;
    for class in classes {
        write_class(&mut str, &class)?;
    }

    fs::write(OUTPUT_PATH, str)?;

    Ok(())
}
